"""
Insight Agent for MerchantIQ system.
Generates AI-powered business insights using LangChain and LLM integration.
"""

import asyncio
import os
from typing import Dict, List, Any, Optional, Union
from datetime import datetime, timedelta
from dataclasses import dataclass
import json

# LangChain imports with fallback handling
try:
    from langchain.llms import OpenAI
    from langchain.chat_models import ChatOpenAI
    from langchain.schema import HumanMessage, SystemMessage
    from langchain.prompts import PromptTemplate, ChatPromptTemplate
    from langchain.chains import LLMChain
    LANGCHAIN_AVAILABLE = True
except ImportError:
    LANGCHAIN_AVAILABLE = False

# OpenAI/Anthropic imports with fallback
try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False

try:
    import anthropic
    ANTHROPIC_AVAILABLE = True
except ImportError:
    ANTHROPIC_AVAILABLE = False

from ..utils.logger import get_logger, performance_log, AgentActionContext


@dataclass
class BusinessInsight:
    """Business insight generated by AI."""
    insight_id: str
    merchant_id: str
    merchant_name: str
    
    # Insight content
    insight_type: str  # 'opportunity', 'risk', 'trend', 'recommendation'
    title: str
    summary: str
    detailed_analysis: str
    
    # Supporting data
    key_metrics: Dict[str, Any]
    confidence_score: float  # 0-1
    priority: str  # 'high', 'medium', 'low'
    
    # Action items
    recommendations: List[str]
    suggested_actions: List[str]
    
    # Metadata
    generated_at: datetime
    model_used: str
    processing_time_ms: float


@dataclass
class MarketInsight:
    """Market-level insight across multiple merchants."""
    insight_id: str
    
    # Content
    insight_type: str  # 'market_trend', 'segment_analysis', 'comparative_analysis'
    title: str
    summary: str
    detailed_analysis: str
    
    # Scope
    merchants_analyzed: int
    data_period: str
    categories_covered: List[str]
    
    # Insights
    key_findings: List[str]
    market_opportunities: List[str]
    risk_factors: List[str]
    
    # Metadata
    generated_at: datetime
    model_used: str


class InsightAgent:
    """Agent responsible for generating AI-powered business insights."""
    
    def __init__(self, config: Optional[Dict] = None):
        """Initialize the Insight Agent.
        
        Args:
            config: Configuration dictionary
        """
        self.config = config or {}
        self.logger = get_logger("agent.insight")
        
        # Check for AI service availability
        self._check_ai_services()
        
        # Agent state
        self.is_running = False
        self.last_insight_time: Optional[datetime] = None
        self.generated_insights_count = 0
        
        # AI configuration
        ai_config = self.config.get('ai', {})
        self.provider = ai_config.get('provider', 'openai')  # 'openai', 'anthropic', 'fallback'
        self.model = ai_config.get('model', 'gpt-3.5-turbo')
        self.temperature = ai_config.get('temperature', 0.7)
        self.max_tokens = ai_config.get('max_tokens', 1000)
        
        # API keys
        self.openai_api_key = os.getenv('OPENAI_API_KEY')
        self.anthropic_api_key = os.getenv('ANTHROPIC_API_KEY')
        
        # Insight configuration
        insight_config = ai_config.get('insights', {})
        self.max_insights_per_merchant = insight_config.get('max_per_merchant', 3)
        self.min_confidence_threshold = insight_config.get('min_confidence', 0.6)
        self.insight_types = insight_config.get('types', [
            'opportunity', 'risk', 'trend', 'recommendation'
        ])
        
        # Initialize AI clients
        self.llm_client = None
        self.chat_client = None
        self._initialize_ai_clients()
        
        # Caches
        self.insight_cache: Dict[str, BusinessInsight] = {}
        self.market_insight_cache: Dict[str, MarketInsight] = {}
        
        # Prompt templates
        self._setup_prompt_templates()
    
    def _check_ai_services(self) -> None:
        """Check availability of AI services."""
        services = {
            'langchain': LANGCHAIN_AVAILABLE,
            'openai': OPENAI_AVAILABLE,
            'anthropic': ANTHROPIC_AVAILABLE
        }
        
        available_services = [name for name, available in services.items() if available]
        self.logger.info(f"Available AI services: {available_services}")
        
        if not any(services.values()):
            self.logger.warning("No AI services available - using fallback text generation")
    
    def _initialize_ai_clients(self) -> None:
        """Initialize AI service clients."""
        try:
            if self.provider == 'openai' and OPENAI_AVAILABLE and self.openai_api_key:
                if LANGCHAIN_AVAILABLE:
                    self.chat_client = ChatOpenAI(
                        openai_api_key=self.openai_api_key,
                        model_name=self.model,
                        temperature=self.temperature,
                        max_tokens=self.max_tokens
                    )
                else:
                    openai.api_key = self.openai_api_key
                    self.llm_client = 'openai_direct'
                
                self.logger.info(f"Initialized OpenAI client with model: {self.model}")
                
            elif self.provider == 'anthropic' and ANTHROPIC_AVAILABLE and self.anthropic_api_key:
                self.llm_client = anthropic.Anthropic(api_key=self.anthropic_api_key)
                self.logger.info("Initialized Anthropic client")
                
            else:
                self.logger.warning("No AI client initialized - using fallback generation")
                self.llm_client = 'fallback'
                
        except Exception as e:
            self.logger.error(f"Failed to initialize AI clients: {e}")
            self.llm_client = 'fallback'
    
    def _setup_prompt_templates(self) -> None:
        """Setup prompt templates for different types of insights."""
        self.templates = {
            'merchant_analysis': """
You are a senior business analyst specializing in merchant evaluation and financial services.
Analyze this merchant's performance data and provide actionable business insights.

Merchant Information:
- Name: {merchant_name}
- ID: {merchant_id}

Performance Metrics:
{metrics}

Attribution Data:
{attribution}

Scoring Results:
{scoring}

Please provide:
1. A concise business insight (2-3 sentences)
2. Key strengths and opportunities
3. Risk factors to monitor
4. 2-3 specific actionable recommendations

Focus on practical, data-driven insights that would help a business team make decisions about this merchant relationship.
""",
            
            'market_trends': """
You are a market research analyst specializing in merchant ecosystem analysis.
Analyze the performance data across multiple merchants to identify market trends and opportunities.

Market Data Summary:
- Total Merchants Analyzed: {merchant_count}
- Time Period: {time_period}
- Categories: {categories}

Top Performing Merchants:
{top_merchants}

Market Metrics:
{market_metrics}

Please provide:
1. Key market trends and patterns
2. High-growth segments or opportunities
3. Emerging risks in the merchant ecosystem
4. Strategic recommendations for market positioning

Focus on insights that would help with portfolio strategy and market positioning decisions.
""",
            
            'risk_assessment': """
You are a risk management specialist analyzing merchant portfolio risk.
Evaluate the risk profile and provide risk-focused insights.

Merchant Risk Profile:
- Name: {merchant_name}
- Risk Score: {risk_score}
- Risk Level: {risk_level}

Risk Factors:
{risk_factors}

Performance Context:
{performance_context}

Please provide:
1. Risk assessment summary
2. Primary risk drivers
3. Early warning indicators to monitor
4. Risk mitigation recommendations

Focus on actionable risk management strategies.
"""
        }
    
    @performance_log
    async def start(self) -> None:
        """Start the insight agent."""
        with AgentActionContext("insight", "start"):
            self.is_running = True
            self.logger.info(f"Insight Agent started with provider: {self.provider}")
    
    async def stop(self) -> None:
        """Stop the insight agent."""
        with AgentActionContext("insight", "stop"):
            self.is_running = False
            self.logger.info("Insight Agent stopped")
    
    @performance_log
    async def generate_insights(
        self,
        merchant_features: Dict[str, Any],
        attribution_results: Dict[str, Any],
        scoring_results: Dict[str, Any]
    ) -> Dict[str, List[BusinessInsight]]:
        """Generate business insights for merchants.
        
        Args:
            merchant_features: Dictionary of MerchantFeatures by merchant_id
            attribution_results: Dictionary of AttributionResult by merchant_id
            scoring_results: Dictionary of MerchantScore by merchant_id
            
        Returns:
            Dictionary mapping merchant_id to list of BusinessInsight objects
        """
        with AgentActionContext("insight", "generate_insights"):
            try:
                insights = {}
                
                # Get common merchants across all datasets
                common_merchants = set(merchant_features.keys()) & set(scoring_results.keys())
                
                if not common_merchants:
                    self.logger.warning("No common merchants found across datasets")
                    return {}
                
                # Generate insights for each merchant
                for merchant_id in common_merchants:
                    features = merchant_features[merchant_id]
                    scoring = scoring_results[merchant_id]
                    attribution = attribution_results.get(merchant_id)
                    
                    merchant_insights = await self._generate_merchant_insights(
                        merchant_id, features, scoring, attribution
                    )
                    
                    if merchant_insights:
                        insights[merchant_id] = merchant_insights
                
                # Update agent state
                self.last_insight_time = datetime.now()
                self.generated_insights_count = sum(len(merchant_insights) for merchant_insights in insights.values())
                
                # Update cache
                for merchant_id, merchant_insights in insights.items():
                    for insight in merchant_insights:
                        self.insight_cache[insight.insight_id] = insight
                
                self.logger.info(f"Generated {self.generated_insights_count} insights for {len(insights)} merchants")
                return insights
                
            except Exception as e:
                self.logger.error(f"Insight generation failed: {e}")
                raise
    
    async def _generate_merchant_insights(
        self,
        merchant_id: str,
        features: Any,
        scoring: Any,
        attribution: Optional[Any] = None
    ) -> List[BusinessInsight]:
        """Generate insights for a specific merchant."""
        insights = []
        
        try:
            # Prepare data for analysis
            merchant_data = self._prepare_merchant_data(features, scoring, attribution)
            
            # Generate different types of insights
            insight_types = ['opportunity', 'risk', 'recommendation']
            
            for insight_type in insight_types:
                if len(insights) >= self.max_insights_per_merchant:
                    break
                
                insight = await self._generate_single_insight(
                    merchant_id, merchant_data, insight_type
                )
                
                if insight and insight.confidence_score >= self.min_confidence_threshold:
                    insights.append(insight)
            
            return insights
            
        except Exception as e:
            self.logger.error(f"Failed to generate insights for merchant {merchant_id}: {e}")
            return []
    
    def _prepare_merchant_data(self, features: Any, scoring: Any, attribution: Optional[Any] = None) -> Dict[str, Any]:
        """Prepare merchant data for AI analysis."""
        data = {
            'merchant_name': getattr(features, 'merchant_name', 'Unknown'),
            'merchant_id': getattr(features, 'merchant_id', ''),
            'metrics': {
                'total_volume': getattr(features, 'total_volume', 0),
                'transaction_count': getattr(features, 'transaction_count', 0),
                'unique_customers': getattr(features, 'unique_customers', 0),
                'avg_transaction_value': getattr(features, 'avg_transaction_value', 0),
                'repeat_customer_ratio': getattr(features, 'repeat_customer_ratio', 0),
                'growth_rate_30d': getattr(features, 'growth_rate_30d', 0),
                'days_active': getattr(features, 'days_active', 0)
            },
            'risk_factors': {
                'chargeback_rate': getattr(features, 'chargeback_rate', 0),
                'fraud_score': getattr(features, 'fraud_score', 0),
                'payment_failure_rate': getattr(features, 'payment_failure_rate', 0),
                'volume_volatility': getattr(features, 'volume_volatility', 0)
            },
            'scoring': {
                'composite_score': getattr(scoring, 'composite_score', 0),
                'value_score': getattr(scoring, 'value_score', 0),
                'risk_score': getattr(scoring, 'risk_score', 0),
                'growth_score': getattr(scoring, 'growth_score', 0),
                'score_tier': getattr(scoring, 'score_tier', 'unknown'),
                'risk_level': getattr(scoring, 'risk_level', 'unknown')
            }
        }
        
        if attribution:
            data['attribution'] = {
                'markov_attribution': getattr(attribution, 'markov_attribution', 0),
                'removal_effect': getattr(attribution, 'removal_effect', 0),
                'incremental_value': getattr(attribution, 'incremental_value', 0),
                'appears_in_journeys': getattr(attribution, 'appears_in_journeys', 0)
            }
        
        return data
    
    async def _generate_single_insight(
        self,
        merchant_id: str,
        merchant_data: Dict[str, Any],
        insight_type: str
    ) -> Optional[BusinessInsight]:
        """Generate a single insight using AI."""
        start_time = datetime.now()
        
        try:
            # Create prompt based on insight type
            prompt = self._create_insight_prompt(merchant_data, insight_type)
            
            # Generate insight using AI
            ai_response = await self._call_ai_service(prompt)
            
            if not ai_response:
                return None
            
            # Parse and structure the response
            insight = self._parse_ai_response(
                merchant_id, merchant_data, insight_type, ai_response, start_time
            )
            
            return insight
            
        except Exception as e:
            self.logger.error(f"Failed to generate {insight_type} insight for {merchant_id}: {e}")
            return None
    
    def _create_insight_prompt(self, merchant_data: Dict[str, Any], insight_type: str) -> str:
        """Create AI prompt based on merchant data and insight type."""
        merchant_name = merchant_data['merchant_name']
        merchant_id = merchant_data['merchant_id']
        
        # Format metrics for prompt
        metrics_text = "\n".join([
            f"- {key.replace('_', ' ').title()}: {value:,.2f}" if isinstance(value, float) else f"- {key.replace('_', ' ').title()}: {value:,}"
            for key, value in merchant_data['metrics'].items()
        ])
        
        scoring_text = "\n".join([
            f"- {key.replace('_', ' ').title()}: {value}"
            for key, value in merchant_data['scoring'].items()
        ])
        
        attribution_text = ""
        if 'attribution' in merchant_data:
            attribution_text = "\n".join([
                f"- {key.replace('_', ' ').title()}: {value:,.2f}" if isinstance(value, float) else f"- {key.replace('_', ' ').title()}: {value:,}"
                for key, value in merchant_data['attribution'].items()
            ])
        
        if insight_type == 'risk':
            template = self.templates['risk_assessment']
            risk_factors_text = "\n".join([
                f"- {key.replace('_', ' ').title()}: {value:.2%}" if 'rate' in key or 'score' in key else f"- {key.replace('_', ' ').title()}: {value:.2f}"
                for key, value in merchant_data['risk_factors'].items()
            ])
            
            return template.format(
                merchant_name=merchant_name,
                risk_score=merchant_data['scoring']['risk_score'],
                risk_level=merchant_data['scoring']['risk_level'],
                risk_factors=risk_factors_text,
                performance_context=f"Metrics:\n{metrics_text}\n\nScoring:\n{scoring_text}"
            )
        else:
            template = self.templates['merchant_analysis']
            return template.format(
                merchant_name=merchant_name,
                merchant_id=merchant_id,
                metrics=metrics_text,
                attribution=attribution_text if attribution_text else "No attribution data available",
                scoring=scoring_text
            )
    
    async def _call_ai_service(self, prompt: str) -> Optional[str]:
        """Call AI service to generate insight."""
        try:
            if self.chat_client and LANGCHAIN_AVAILABLE:
                # Use LangChain ChatOpenAI
                messages = [
                    SystemMessage(content="You are a senior business analyst specializing in merchant evaluation."),
                    HumanMessage(content=prompt)
                ]
                response = await asyncio.to_thread(self.chat_client, messages)
                return response.content
                
            elif self.llm_client == 'openai_direct' and OPENAI_AVAILABLE:
                # Use OpenAI directly
                response = await asyncio.to_thread(
                    openai.ChatCompletion.create,
                    model=self.model,
                    messages=[
                        {"role": "system", "content": "You are a senior business analyst specializing in merchant evaluation."},
                        {"role": "user", "content": prompt}
                    ],
                    temperature=self.temperature,
                    max_tokens=self.max_tokens
                )
                return response.choices[0].message.content
                
            elif isinstance(self.llm_client, anthropic.Anthropic):
                # Use Anthropic
                response = await asyncio.to_thread(
                    self.llm_client.completions.create,
                    model="claude-3-sonnet-20240229",
                    max_tokens=self.max_tokens,
                    temperature=self.temperature,
                    prompt=f"\n\nHuman: {prompt}\n\nAssistant:"
                )
                return response.completion
                
            else:
                # Fallback to rule-based insight generation
                return self._generate_fallback_insight(prompt)
                
        except Exception as e:
            self.logger.error(f"AI service call failed: {e}")
            return self._generate_fallback_insight(prompt)
    
    def _generate_fallback_insight(self, prompt: str) -> str:
        """Generate fallback insight when AI services are not available."""
        # Extract key information from prompt for rule-based insight
        if "Risk Score:" in prompt:
            return """
Risk Assessment Summary:
This merchant shows moderate risk indicators based on transaction patterns and payment behavior.

Primary Risk Drivers:
- Transaction volume volatility may indicate inconsistent business performance
- Monitor payment failure rates and chargeback patterns

Early Warning Indicators:
- Sudden changes in transaction frequency
- Increases in dispute rates
- Customer retention declining

Risk Mitigation Recommendations:
- Implement enhanced monitoring for transaction anomalies
- Consider tiered approval limits based on transaction patterns
- Regular review of payment processing metrics
"""
        else:
            return """
Business Insight Summary:
This merchant demonstrates solid performance metrics with opportunities for growth.

Key Strengths:
- Consistent transaction volume and customer base
- Reasonable customer retention rates
- Stable payment processing performance

Opportunities:
- Focus on increasing average transaction value
- Implement customer loyalty programs to improve retention
- Explore growth opportunities in underserved segments

Recommendations:
- Monitor growth trajectory and customer acquisition costs
- Consider partnership opportunities for expansion
- Implement data-driven marketing strategies
"""
    
    def _parse_ai_response(
        self,
        merchant_id: str,
        merchant_data: Dict[str, Any],
        insight_type: str,
        ai_response: str,
        start_time: datetime
    ) -> BusinessInsight:
        """Parse AI response into structured BusinessInsight."""
        processing_time = (datetime.now() - start_time).total_seconds() * 1000
        
        # Extract title (first line or generate one)
        lines = ai_response.strip().split('\n')
        title = lines[0][:100] if lines else f"{insight_type.title()} Analysis"
        
        # Extract summary (first paragraph)
        paragraphs = ai_response.split('\n\n')
        summary = paragraphs[0][:300] if paragraphs else ai_response[:300]
        
        # Extract recommendations (lines starting with - or numbers)
        recommendations = []
        suggested_actions = []
        
        for line in lines:
            line = line.strip()
            if line.startswith(('- ', 'â€¢ ', '1. ', '2. ', '3. ')):
                if 'recommend' in line.lower() or 'suggest' in line.lower():
                    recommendations.append(line)
                else:
                    suggested_actions.append(line)
        
        # Determine priority based on scores
        composite_score = merchant_data['scoring']['composite_score']
        risk_score = merchant_data['scoring']['risk_score']
        
        if composite_score > 80 or risk_score > 70:
            priority = 'high'
        elif composite_score > 60 or risk_score > 40:
            priority = 'medium'
        else:
            priority = 'low'
        
        # Calculate confidence based on data quality
        confidence = 0.8  # Base confidence
        if merchant_data['metrics']['transaction_count'] > 100:
            confidence += 0.1
        if 'attribution' in merchant_data:
            confidence += 0.05
        
        confidence = min(1.0, confidence)
        
        # Generate unique insight ID
        insight_id = f"{merchant_id}_{insight_type}_{int(start_time.timestamp())}"
        
        return BusinessInsight(
            insight_id=insight_id,
            merchant_id=merchant_id,
            merchant_name=merchant_data['merchant_name'],
            insight_type=insight_type,
            title=title,
            summary=summary,
            detailed_analysis=ai_response,
            key_metrics=merchant_data['metrics'],
            confidence_score=confidence,
            priority=priority,
            recommendations=recommendations[:3],  # Limit to 3
            suggested_actions=suggested_actions[:3],  # Limit to 3
            generated_at=datetime.now(),
            model_used=self.model if self.llm_client != 'fallback' else 'rule-based',
            processing_time_ms=processing_time
        )
    
    @performance_log
    async def generate_market_insights(
        self,
        all_merchant_data: Dict[str, Dict[str, Any]]
    ) -> List[MarketInsight]:
        """Generate market-level insights across all merchants."""
        with AgentActionContext("insight", "generate_market_insights"):
            try:
                if not all_merchant_data:
                    return []
                
                # Prepare market summary
                market_summary = self._prepare_market_summary(all_merchant_data)
                
                # Generate market insights
                market_insights = []
                
                # Market trend analysis
                trend_insight = await self._generate_market_trend_insight(market_summary)
                if trend_insight:
                    market_insights.append(trend_insight)
                
                # Segment analysis
                segment_insight = await self._generate_segment_insight(market_summary)
                if segment_insight:
                    market_insights.append(segment_insight)
                
                # Update cache
                for insight in market_insights:
                    self.market_insight_cache[insight.insight_id] = insight
                
                self.logger.info(f"Generated {len(market_insights)} market insights")
                return market_insights
                
            except Exception as e:
                self.logger.error(f"Market insight generation failed: {e}")
                return []
    
    def _prepare_market_summary(self, all_merchant_data: Dict[str, Dict[str, Any]]) -> Dict[str, Any]:
        """Prepare market-level summary data."""
        if not all_merchant_data:
            return {}
        
        # Aggregate metrics
        total_volume = sum(data['metrics']['total_volume'] for data in all_merchant_data.values())
        total_transactions = sum(data['metrics']['transaction_count'] for data in all_merchant_data.values())
        avg_composite_score = sum(data['scoring']['composite_score'] for data in all_merchant_data.values()) / len(all_merchant_data)
        
        # Top performers
        top_merchants = sorted(
            all_merchant_data.items(),
            key=lambda x: x[1]['scoring']['composite_score'],
            reverse=True
        )[:10]
        
        # Categories
        categories = set()
        for data in all_merchant_data.values():
            # This would need to be extracted from features if category is available
            categories.add("General")  # Placeholder
        
        return {
            'merchant_count': len(all_merchant_data),
            'total_volume': total_volume,
            'total_transactions': total_transactions,
            'avg_composite_score': avg_composite_score,
            'top_merchants': top_merchants,
            'categories': list(categories),
            'time_period': "Last 30 days"  # Placeholder
        }
    
    async def _generate_market_trend_insight(self, market_summary: Dict[str, Any]) -> Optional[MarketInsight]:
        """Generate market trend insight."""
        try:
            prompt = self.templates['market_trends'].format(
                merchant_count=market_summary['merchant_count'],
                time_period=market_summary['time_period'],
                categories=', '.join(market_summary['categories']),
                top_merchants='\n'.join([f"- {data['merchant_name']}: Score {data['scoring']['composite_score']:.1f}" 
                                       for _, data in market_summary['top_merchants'][:5]]),
                market_metrics=f"""
- Total Volume: ${market_summary['total_volume']:,.2f}
- Total Transactions: {market_summary['total_transactions']:,}
- Average Merchant Score: {market_summary['avg_composite_score']:.1f}
"""
            )
            
            ai_response = await self._call_ai_service(prompt)
            
            if ai_response:
                insight_id = f"market_trend_{int(datetime.now().timestamp())}"
                
                return MarketInsight(
                    insight_id=insight_id,
                    insight_type='market_trend',
                    title="Market Performance Analysis",
                    summary=ai_response[:300],
                    detailed_analysis=ai_response,
                    merchants_analyzed=market_summary['merchant_count'],
                    data_period=market_summary['time_period'],
                    categories_covered=market_summary['categories'],
                    key_findings=[],  # Would parse from AI response
                    market_opportunities=[],  # Would parse from AI response
                    risk_factors=[],  # Would parse from AI response
                    generated_at=datetime.now(),
                    model_used=self.model if self.llm_client != 'fallback' else 'rule-based'
                )
            
            return None
            
        except Exception as e:
            self.logger.error(f"Market trend insight generation failed: {e}")
            return None
    
    async def _generate_segment_insight(self, market_summary: Dict[str, Any]) -> Optional[MarketInsight]:
        """Generate segment analysis insight."""
        # Similar implementation to market trend but focused on segments
        # This is a simplified version
        try:
            insight_id = f"segment_analysis_{int(datetime.now().timestamp())}"
            
            return MarketInsight(
                insight_id=insight_id,
                insight_type='segment_analysis',
                title="Merchant Segment Analysis",
                summary="Analysis of merchant performance across different segments and categories.",
                detailed_analysis="Detailed segment performance analysis with growth opportunities and risk factors.",
                merchants_analyzed=market_summary['merchant_count'],
                data_period=market_summary['time_period'],
                categories_covered=market_summary['categories'],
                key_findings=["Strong performance in premium segment", "Growth opportunities in mid-tier"],
                market_opportunities=["Expand premium partnerships", "Develop mid-tier acquisition"],
                risk_factors=["Market saturation in low-tier", "Increased competition"],
                generated_at=datetime.now(),
                model_used=self.model if self.llm_client != 'fallback' else 'rule-based'
            )
            
        except Exception as e:
            self.logger.error(f"Segment insight generation failed: {e}")
            return None
    
    def get_status(self) -> Dict[str, Any]:
        """Get current agent status."""
        return {
            "agent_name": "InsightAgent",
            "is_running": self.is_running,
            "last_insight_time": self.last_insight_time.isoformat() if self.last_insight_time else None,
            "generated_insights_count": self.generated_insights_count,
            "insight_cache_size": len(self.insight_cache),
            "market_insight_cache_size": len(self.market_insight_cache),
            "ai_provider": self.provider,
            "model": self.model,
            "services_available": {
                "langchain": LANGCHAIN_AVAILABLE,
                "openai": OPENAI_AVAILABLE,
                "anthropic": ANTHROPIC_AVAILABLE
            },
            "configuration": {
                "max_insights_per_merchant": self.max_insights_per_merchant,
                "min_confidence_threshold": self.min_confidence_threshold,
                "temperature": self.temperature
            }
        }
    
    async def get_merchant_insights(self, merchant_id: str) -> List[BusinessInsight]:
        """Get insights for a specific merchant."""
        return [insight for insight in self.insight_cache.values() if insight.merchant_id == merchant_id]
    
    async def get_insights_by_type(self, insight_type: str) -> List[BusinessInsight]:
        """Get insights by type."""
        return [insight for insight in self.insight_cache.values() if insight.insight_type == insight_type]
    
    async def get_high_priority_insights(self) -> List[BusinessInsight]:
        """Get high priority insights."""
        return [insight for insight in self.insight_cache.values() if insight.priority == 'high']